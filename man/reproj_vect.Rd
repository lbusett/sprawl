% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/reproj_vect.R
\name{reproj_vect}
\alias{reproj_vect}
\title{Reproject a vector "R" object or file}
\usage{
reproj_vect(in_vect, in_projobj, out_file = NULL, out_type = "vectobject",
  out_class = NULL, overwrite = FALSE, verbose = TRUE)
}
\arguments{
\item{in_vect}{A vector object (\code{*sf} or \code{sp}), or the path to a vector file}

\item{in_projobj}{\code{R} object or filename from which the output projection should
be derived (see @description )}

\item{out_file}{\code{character} Path where the reprojected vector should be saved.
If NULL, the reprojected vector is not saved, but just sent back to the
caller, Default: NULL}

\item{out_type}{\code{character ["vectfile" | "vectobject"]} If "vectfile", and \code{out_file}
is not NULL, the function returns the name of the saved shapefile. Otherwise,
it returns the reprojected vector object, with the format specified by
out_class,  Default: 'vectobject'}

\item{out_class}{\code{character ["sf" | "sp"]} Specifies if the reprojected object
should have class \code{sf} or \code{sp}. If NULL, the returned reprojected
object has the same class of \code{in_vect}, Default: NULL}

\item{overwrite}{\code{logical} If TRUE, overwrite existing files, Default: FALSE}

\item{verbose}{\code{logical} If FALSE, suppress processing messages, Default: TRUE}
}
\value{
a vector of class \code{*sf} or \code{sp} (depending on \code{out_class}), or the
path of the file where the reprojected input was saved (if out_type == "vectfile")
}
\description{
Reproject a vector "R" object or file to a different reference
system. The function is a simple wrapper around \code{sf::st_tranform} with
additional checks on inputs allowing to specify the output projection
in several ways:
1: passing a valid proj4 string (e.g., \code{reproj_vect(in_vect, "+init=epsg:4326")}
2: passing a numeric or character that can be interpreted as an
EPSG code (e.g., \code{reproj_vect(in_vect, 4326)});
3: passing the name of a valid \code{R} vector or raster object:
(e.g.,\code{reproj_vect(in_vect, rast_obj)}, with \code{rast_obj}
being an existing \code{R} object;
4: passing the path to a valid vector or raster file:
EPSG code (e.g.,\code{reproj_vect(in_vect, "D:/Temp/myfile.tif")}

The reprojected vector can be automatically saved to a shapefile through
\code{write_shape} by specifying a valid path with the \code{out_file} argument.
}
\examples{
\dontrun{
library(sprawl.data)
library(gridExtra)
# reproject a vector file
in_vect <- system.file("extdata/shapes","lc_polys.shp",
                                   package = "sprawl.data")
in_vect <- read_vect(in_vect)
bounds  <- get_boundaries("PHL", 1)
# Input projection is:
get_proj4string(in_vect)
plot_vect(in_vect, fill_var = "category", borders_layer = bounds)

# reproject to 3857 (web mercator)
out_proj <-  3857
out_vect <- reproj_vect(in_vect, 3857)
# Output projection is:
get_proj4string(out_vect)

# Do the same, but also save the output to file
out_file <- tempfile(fileext = ".shp")
out_proj <- "+proj=sinu +lon_0=0 +x_0=0 +y_0=0 +a=6371007.181 +b=6371007.181 +units=m +no_defs"
out_vect <- reproj_vect(in_vect, 3857, out_file = out_file)
read_vect(out_file)

# use a different spatial file or object to set the output projectionaaa:
rast <- system.file("extdata/MODIS_test", "EVIts_test.tif",
  package = "sprawl.data")
out_vect <- reproj_vect(in_vect, rast)
# Output projection is:
get_proj4string(out_vect)
p1 <- plot_vect(in_vect, borders_layer = bounds, fill_var = "category",
   title = "Original (lat/lon)")
p2 <- plot_vect(out_vect, borders_layer = bounds, fill_var = "category",
   title = "Reprojected (sinusoidal)")
gridExtra::grid.arrange(p1,p2, ncol = 2)
}
}
\seealso{
sf::st_write sf::st_transform write_shape
}
\author{
Lorenzo Busetto, phD (2017) \href{mailto:lbusett@gmail.com}{lbusett@gmail.com}
}
