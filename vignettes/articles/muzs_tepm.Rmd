---
title: MUZS v0
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
main_folder <- "/home/lb/projects/SATFARMING/BF_test_datasets/Bonifiche_Ferraresi/"
library(viridisLite)
library(leaflet)
library(patchwork)
library(sprawl)
library(mapview)
```

# Metodo e considerazioni

* Creati a partire da __intersezione tra risultati di un clustering sul layer di 
  resistività superficiale e la mappa di uso dei suoli__
  
* I risultati "grezzi" delle intersezioni vengono __processati per ridurre il numero 
  complessivo dei poligoni__, utilizzando una tecnica automatica di rimozione degli 
  "sliver". I settaggi di questo processamento possono essere modificati se si 
  desidera ottenere una maggiore "generalizzazione" (i.e., meno poligoni), a scapito
  del "contenuto informativo"

* Le tabelle associate riportano i __valori medi dei punti di campionamento dei suoli 
  (livello topsoil)__ per il tipo di suolo corrispondente a ciascuna MUZ, più 
  __i valori di resistività medi nei tre layers__ (Cliccate su un poligono per vederli).
  Ora che il framework é più o meno completo, comunque, diventa abbastanza semplice
  includere altri dati (es. dati punto campionamento più vicino, dati ricavati 
  da spazializzazione dei punti di campionamento, ecc.) o escludere quelli non 
  necessari. Questa é una cosa da decidere assieme in futuro. 
  
* Una cosa che mi é venuta in mente e che potrebbe facilitare l'assegnazione delle MUZ
  alle classi di idoneità é che potremmo passare dal semplice riporto "numerico"
  degli attributi dei suoli (es. ph = 5.8, csc = 70, mg = 20,...), ad un riporto più "semantico"
  (es., "suolo molto acido", "suolo povero" - vedete per esempio
  http://www.agraria.unirc.it/documentazione/materiale_didattico/1462_2017_432_26937.pdf - pagina 65).

* La procedura di clustering per l'individuazione delle zone é __pensata per 
  essere flessibile__: In questo caso, ho utilizzato come input i dati di resistività, 
  ma lo stesso algoritmo o un algoritmo simile potrà essere applicato a qualunque
  dato Raster (magari con qualche modifica che vedremo in futuro). Ad esempio, 
  potrebbe essere utilizzato per creare le MUZ a partire da immagini satellitari 
  per le fertilizzazioni di copertura, o nel caso in cu iinformazioni di dettaglio
  sulle caratteristiche dei suoli non siano disponibili. 
  
* La procedura di riporto delle informazioni relative alle MUZ é pensata per essere __flessibile
  in caso alcuni dati siano mancanti__ (e.g., non cesiste la mappa dei suoli, o non esistono i
  dati sui punti di campionamento, oppure si vuole utilizzare solo la mappa dei suoli per creare
  le MUZ (vedete ultima immagine))

* La procedura é già __considerevolemente automatizzata__, a partire da datasets 
  organizzati secondo gli standard decisi. In futuro andrà però ripulito il codice, 
  mettendo in fila i diversi "pezzi" per __permettere una maggiore facilità di utilizzo
  e possibilmente creare un interfaccia grafica__ che permetta di utilizzarla facilmente
  (magari anche permettendo di selezionare facilmente quali datasets vengono utilizzati
  per il clustering)).


# Risultati


## Cortona

I colori rappresentano __il "numero" della MUZ all'interno di ciacun appezzamento__. 
Qui tipicamente abbiamo 2-4 MUZ per appezzamento, tranne dove si 
intersecano molti tipi di suoli differenti

<br>

```{r echo=FALSE, fig.height=6, fig.width=8.5, message=FALSE, warning=FALSE, paged.print=FALSE}
clrs <- plasma
indata <- sprawl::read_vect(file.path(main_folder, "Cortona/vector/management_zones/bf_cortona_muzv0.gpkg"))
mapview::mapview(indata, zcol = c("muz_n"), col.regions = viridis, color = "grey75", lwd = 0.5,
                 alpha.regions = 0.7, map.types = c("Esri.WorldImagery", "OpenStreetMap"),
                 legend = T, highlight = highlightOptions(bringToFront = TRUE, opacity = 1,
                                                          weight = 2, sendToBack = FALSE, 
                                                          color = "white"))@map
```
<br>

L'utilizzo della resistività come variabile guida per il clustering permette di 
evidenziare situazioni di variabilità non evidenti nella mappa dei suoli. In 
questo caso, ad esempio, vedete come __a parità di suolo nel campo siano presenti__ 
__più zone fortemente diverse__ come resistività. 

<br>

```{r echo=FALSE, fig.height=6, fig.width=8.5, message=FALSE, warning=FALSE, paged.print=FALSE}
library(sf)
library(patchwork)
library(sprawl)
clrs <- plasma
indata <- sprawl::read_vect(file.path(main_folder, "Cortona/vector/management_zones/bf_cortona_muzv0.gpkg")) %>% 
  dplyr::filter(id_geom %in% c("0636", "0637"))
mapview::mapview(indata, zcol = c("rho_0"), col.regions = magma, color = "grey75", lwd = 0.5,
                 alpha.regions = 0.7, map.types = c("Esri.WorldImagery", "OpenStreetMap"),
                 legend = T, highlight = highlightOptions(bringToFront = TRUE, opacity = 1,
                                                          weight = 2, sendToBack = FALSE, 
                                                          color = "white"))@map
                   
```

<br>

L'__interserzione del clustering con la mappa dei suoli__ permette di gestire 
al meglio queste condizioni: 

<br>

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
p1 <- plot_vect(indata, fill_var = "muz_n", scalebar = F, show_grid = F, show_axis = F)
p2 <- plot_vect(indata, fill_var = "soil_id", subtitle = "Tipo di Suolo", scalebar = F, show_axis = F)
p3 <- plot_vect(indata, fill_var = "rho_0", palette_name = "RdYlBu", subtitle = "Resistività", scalebar = F, show_axis = F)
p2 + p3 + p1 + plot_layout(ncol = 2) 
```

<br>

## Jolanda

Il caso di Jolanda é più complesso, a causa della forte eterogeneità delle caratteristiche
del suolo e delle grandi dimensioni dei singoli appezzamenti. Il numero di 
MUZ per appezzamento si mantiene comunque relativamente basso, tranne in casi 
particolari (es. campo 74 - ma quel campo in realtà sarebbe da "splittare", secondo me)

<br>

```{r echo=FALSE, fig.height=6, fig.width=8.5, message=FALSE, warning=FALSE, paged.print=FALSE}
clrs <- plasma
indata <- sprawl::read_vect(file.path(main_folder, "Jolanda/vector/management_zones/bf_jolanda_muzv0.gpkg"))
mapview::mapview(indata, zcol = c("muz_n"), col.regions = viridis, color = "grey75", lwd = 0.5,
                 alpha.regions = 0.7, map.types = c("Esri.WorldImagery", "OpenStreetMap"),
                 legend = T, highlight = highlightOptions(bringToFront = TRUE, opacity = 1,
                                                          weight = 2, sendToBack = FALSE, 
                                                          color = "white"))@map
```

<br>

## Arborea - muz basate su intersezione clustering resistività e carta suoli

```{r echo=FALSE, fig.height=6, fig.width=8.5, message=FALSE, warning=FALSE, paged.print=FALSE}
clrs <- plasma
indata <- sprawl::read_vect(file.path(main_folder, "Arborea/vector/management_zones/bf_arborea_muzv0_clust.gpkg"))
mapview::mapview(indata, zcol = c("muz_n"), col.regions = viridis, color = "grey75", lwd = 0.5,
                 alpha.regions = 0.7, map.types = c("Esri.WorldImagery", "OpenStreetMap"), 
                 legend = T, highlight = highlightOptions(bringToFront = TRUE, opacity = 1,
                                                          weight = 2, sendToBack = FALSE, 
                                                          color = "white"))@map
```

<br>

## Arborea - muz basate esclusivamente sulla carta dei suoli

Nel caso di Arborea, l'analisi dei dati disponibili ha evidenziato che __i limiti__ 
__delle classi di suolo sembrano essere stati derivati esclusivamente da una__ 
__"classatura" della resistività__. In questo caso, l'ulteriore "suddivisione"
dei poligoni in base al clustering sulla resistività può risultare inutile o 
controproducente. Qui sotto vedete quindi il risultato otenuto utilizzando soltanto 
i dati della carta dei suoli come dato di input per la creazione delle MUZ

<br>

```{r echo=FALSE, fig.height=6, fig.width=8.5, message=FALSE, warning=FALSE, paged.print=FALSE}
clrs <- plasma
indata <- sprawl::read_vect(file.path(main_folder, "Arborea/vector/management_zones/bf_arborea_muzv0_noclust.gpkg"))
mapview::mapview(indata, zcol = c("muz_n"), col.regions = viridis, color = "grey75", lwd = 0.5,
                 alpha.regions = 0.7, map.types = c("Esri.WorldImagery", "OpenStreetMap"), 
                 legend = T, highlight = highlightOptions(bringToFront = TRUE, opacity = 1,
                                                          weight = 2, sendToBack = FALSE, 
                                                          color = "white"))@map

```

