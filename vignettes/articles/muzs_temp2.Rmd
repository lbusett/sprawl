---
title: MUZS v0 - UPDATE
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
main_folder <- "/home/lb/projects/SATFARMING/BF_test_datasets/Bonifiche_Ferraresi/"
library(viridisLite)
library(leaflet)
library(patchwork)
library(sprawl)
library(mapview)
```

# Calcolo z-score e riaggregazione MUZs

Ho aggiunto un nuovo campo alla tabella delle MUZ. E' calcolato in base al 
  confronto tra la resistività di ogni MUZ e la resistività media delle MUZs
  appartenenti alla stessa classe di suolo. Il campo si chiama "rho_z_score" e 
  si interpreta cosi:
  
  * MUZ con valori di rho_z_score > 2 o < -2 corrispondono ad aree che hanno valori di resistività     molto maggiori o molto minori rispetto alla media di quel suolo; 
  * MUZ con valori di rho_z_score tra -2 e -1 (o tra 1 e 2) corrispondono ad aree che hanno   
    valori di resistività maggiori o minori rispetto alla media di quel suolo, ma non
    di troppo (tra 1 e 2 sigma); 
  * MUZ con valori di rho_z_score tra -1 e 1 corrispondono ad aree che hanno   
    valori di resistività maggiori più o meno in linea con la media di quel tipo di suolo
    
Questa nuova variabile aiuta ad identificare MUZ con caratteristiche differenti 
rispetto a quelle generali del suolo. La nuova variabile "rho_z_score_cl" riassume
il dato in categorie: "Very High", "High", "Average", "Low", "Very Low".

A questo punto, la combinazione tra "id_soil e "rho_z_score_cl" indica zone 
ragionevolmete "omogenee", ossia appartenti a una classe di suolo e a una classe
di resistività rispetto alla media. La mappa sotto mostra il risultato per 
Jolanda. In questo caso, a MUZ code simile corrispondono "simili caratteristiche"
(sebbene ci portiamo dietro ancora qualche problema legato alle solite questioni 
delle data di misura della resistività)

<br>


```{r echo=FALSE, fig.height=6, fig.width=8.5, message=FALSE, warning=FALSE, paged.print=FALSE}
clrs <- plasma
indata <- sprawl::read_vect("/home/lb/tmp/buttami/bf/muznew/bf_jolanda_muz.gpkg")
mapview::mapview(indata, zcol = c("muz_code"), col.regions = viridis, color = "grey75", lwd = 0.5,
                 alpha.regions = 0.7, map.types = c("Esri.WorldImagery", "OpenStreetMap"),
                 legend = T, highlight = highlightOptions(bringToFront = TRUE, opacity = 1,
                                                          weight = 2, sendToBack = FALSE, 
                                                          color = "white"))@map
```
<br>

Qui vedete un risultato simile solo per i campi MAIS 2018 di Jolanda: 

```{r echo=FALSE, fig.height=6, fig.width=8.5, message=FALSE, warning=FALSE, paged.print=FALSE}
clrs <- plasma
indata <- sprawl::read_vect("/home/lb/tmp/buttami/bf/muznew/bf_jolanda_muz_maize.gpkg")
mapview::mapview(indata, zcol = c("muz_code"), col.regions = viridis, color = "grey75", lwd = 0.5,
                 alpha.regions = 0.7, map.types = c("Esri.WorldImagery", "OpenStreetMap"),
                 legend = T, highlight = highlightOptions(bringToFront = TRUE, opacity = 1,
                                                          weight = 2, sendToBack = FALSE, 
                                                          color = "white"))@map
```

<br>

Questa rappresentazione risulta un po' più semplice da gestire della precedente, 
secondo me, pur permettendoci ancora di gestire le cose "campo per campo", e quindi (
in caso) di aggiustare le cose in base a condizioni particolari (es. campo in 
cui la resistività é disomogenea rispetto al resto a causa della diversa data). 
Di contro, il "numero" di casi con cui lavorare resta abbastanza alto, anche se
le nuove variabili ci permettono di "aggregarle" facilmente in gruppi ragionevolmente
omeogenei.


# Ulteriore semplificazione: "Dissolvimento" dei poligoni con MUZ_code comune

Un' ultereiore semplificazione si può ottenere a questo punto trattando tutte le
aree che hanno lo stesso "muz_code" (i.e., la stessa combinazione "tipo suolo" + 
classe resistività) come un'entità omogenea. Questo si fa con un'operazione di 
"dissolve" spaziale, di cui sotto vedete i risultati: muovendovi con il mouse 
sulla mappa vedrete i confini di ogni "macro-muz". Nel caso di Jolanda, che 
é complesso, ci troviamo con un numero totale di MUZ pari a 64 (gestibile....)

<br>


```{r echo=FALSE, fig.height=6, fig.width=8.5, message=FALSE, warning=FALSE, paged.print=FALSE}
clrs <- plasma
indata <- sprawl::read_vect("/home/lb/tmp/buttami/bf/muznew/bf_jolanda_muz_small.gpkg")
mapview::mapview(indata, zcol = c("muz_code"), col.regions = viridis, color = "grey75", lwd = 0.5,
                 alpha.regions = 0.7, map.types = c("Esri.WorldImagery", "OpenStreetMap"),
                 legend = T, highlight = highlightOptions(bringToFront = TRUE, opacity = 1,
                                                          weight = 2, sendToBack = FALSE, 
                                                          color = "white"))@map
```
<br>

Di nuovo, qui vedete un risultato simile solo per i campi MAIS 2018 di Jolanda: 

```{r echo=FALSE, fig.height=6, fig.width=8.5, message=FALSE, warning=FALSE, paged.print=FALSE}
clrs <- plasma
indata <- sprawl::read_vect("/home/lb/tmp/buttami/bf/muznew/bf_jolanda_muz_small_maize.gpkg")
mapview::mapview(indata, zcol = c("muz_code"), col.regions = viridis, color = "grey75", lwd = 0.5,
                 alpha.regions = 0.7, map.types = c("Esri.WorldImagery", "OpenStreetMap"),
                 legend = T, highlight = highlightOptions(bringToFront = TRUE, opacity = 1,
                                                          weight = 2, sendToBack = FALSE, 
                                                          color = "white"))@map
```

Il vantaggio di quest'ulteriore semplificazione é la riduzione del numero di casi 
da gestire. Lo svantaggio, é che non ci permette più di gestire casi particolari. 
In più, lavorando così, si vanno un po'a perdere le indicazioni "quantitiative"
relative alla resistività.
